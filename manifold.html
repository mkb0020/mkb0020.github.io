<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
  <title>CALABI-YAU MANIFOLD ♡ mkb0020</title>
  <link rel="stylesheet" href="assets/css/style.css">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <meta name="description" content="Interactive 6D Calabi-Yau manifold visualizer – spin, zoom, and explore extra dimensions" />
</head>
<body>

  <nav class="navbar">
    <div class="nav-container">
      <a href="https://mkb0020.github.io">
        <div class="home-icon"></div>
      </a>
      <div class="logo">♡ mkb0020</div>
      <div class="nav-spacer"></div>
    </div>
  </nav>

  <div class="JS-page">
    <div class="JS-controls">
      <h1>CALABI-YAU MANIFOLD</h1>
 


      <div class="cyber-card">
        <button class="cyber-btn2" id="rotateBtn"><h3>⏸ Pause Rotation</h3></button>
        <button class="cyber-btn2" id="regenerateBtn" style="margin-top: 0.5rem;"><h3>Regenerate</h3></button>
    
        <div class="slider-control">
          <label for="complexitySlider">Mesh Complexity: <span id="complexityValue">30</span></label>
          <input type="range" id="complexitySlider" min="10" max="60" value="30" step="5">
        </div>
 
        <h3 style="font-size: 1rem; margin-bottom: 0.8rem;">Zoom Controls</h3>
        <div class="zoom-controls">
          <button class="cyber-btn" id="zoomInBtn"><h1>+</h1></button>
          <button class="cyber-btn" id="zoomOutBtn"><h1>-</h1></button>
          <button class="cyber-btn" id="resetZoomBtn"><h3>Reset</h3></button>
        </div>
      </div>

      <div style="display: flex; gap: 1rem;">
        <button class="btn-quantum-pulse" onclick="openModal('aboutModal')">About</button>
        <button class="btn-quantum-pulse" onclick="openModal('controlsModal')">Controls</button>
      </div>


    </div>

    <div class="JS-container" id="JSCanvas"></div>
  </div>

  <!-- ABOUT MODAL -->
  <div id="aboutModal" class="modal" onclick="closeModal('aboutModal', event)">
    <div class="modal-content" onclick="event.stopPropagation()">
      <div class="modal-header">
        <div class="modal-title">A Calabi-What?</div>
        <button class="btn-spinX" onclick="closeModal('aboutModal')">X</button>
      </div>
      <div class="modal-body">
        <p><div class="NeonNote">
          Tiny six-dimensional origami for the universe!
        </div></p>

        <div class="modal-section">
          <p style="margin-bottom: 1rem;"><div class="holo-card">
            A Calabi-Yau Manifold is a delicately curved, compact complex shape that's Ricci-flat and carries a holomorphic volume form, meaning it has the kind of internal symmetry mathematicians adore. It lives in six real dimensions (three complex dimensions), but we show it here as a 3D projection you can spin, zoom, and explore.
          </div></p>
        </div>

        <div class="modal-section">
          <p style="margin-bottom: 1rem;">
          <div class="holo-card">
            <ul style="margin-bottom: 1rem;">
              <li><strong>In geometry</strong> - Calabi-Yau spaces are central examples in complex differential geometry and algebraic geometry</li>
              <li><strong>In physics</strong> - They're the favorite hiding places for extra dimensions in string theory</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="controlsModal" class="modal" onclick="closeModal('controlsModal', event)">
    <div class="modal-content" onclick="event.stopPropagation()">
      <div class="modal-header">
        <div class="modal-title">Animation Controls</div>
        <button class="btn-spinX" onclick="closeModal('controlsModal')">X</button>
      </div>
      <div class="modal-body">
        <div class="modal-section">
          <p style="margin-bottom: 1rem;">
          <div class="holo-card">
              <strong>For PC / Desktop:</strong> 
              <ul>
                <li><strong>Rotate</strong> - Drag with your mouse to rotate the manifold manually</li>
                <li><strong>Zoom</strong> - Use the zoom buttons or scroll wheel</li>
                <li><strong>Details</strong> - Use the slider to increase or decrease mesh complexity</li>
              </ul>
          </div></p>
        </div>
        <div class="modal-section">
          <p style="margin-bottom: 1rem;">
          <div class="holo-card">
              <strong>For Mobile Devices:</strong>
              <ul>
                <li>Use touch to drag and pinch to zoom</li>
              </ul>
          </div>
          </p>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, manifoldGroup;
    let container;
    let isRotating = true;
    let isDragging = false;
    let previousPosition = { x: 0, y: 0 };
    let complexity = 30;
    let currentZoom = 5;
    const initialCameraZ = 5;

    function openModal(id) {
      document.getElementById(id).style.display = 'flex';
    }

    function closeModal(id, event) {
      if (event) event.stopPropagation();
      document.getElementById(id).style.display = 'none';
    }

    function init() {
      container = document.getElementById('JSCanvas');
      if (!container) return;

      const resizeCanvas = () => {
        const rect = container.getBoundingClientRect();
        renderer.setSize(rect.width, rect.height);
        camera.aspect = rect.width / rect.height;
        camera.updateProjectionMatrix();
      };

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
      camera.position.z = initialCameraZ;

      renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true,
        powerPreference: "high-performance"
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0xffffff, 1);
      pointLight.position.set(5, 5, 5);
      scene.add(pointLight);

      createManifold();
      
      let touchStartPos = null;
      let pinchDistance = 0;
      let initialPinchZoom = 0;

      const getClientPos = (e) => {
        if (e.touches && e.touches.length > 0) {
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
      };

      const handlePointerStart = (e) => {
        e.preventDefault();
        isDragging = true;
        touchStartPos = getClientPos(e);
        previousPosition = { ...touchStartPos };
        
        if (e.touches && e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          pinchDistance = Math.sqrt(dx * dx + dy * dy);
          initialPinchZoom = currentZoom;
        }
      };

      const handlePointerMove = (e) => {
        if (!isDragging || !manifoldGroup) return;
        e.preventDefault();

        if (e.touches && e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const currentDistance = Math.sqrt(dx * dx + dy * dy);
          
          if (pinchDistance > 0) {
            const scale = currentDistance / pinchDistance;
            currentZoom = initialPinchZoom * (1 / scale);
            currentZoom = Math.max(1, Math.min(12, currentZoom));
            camera.position.z = currentZoom;
          }
          pinchDistance = currentDistance;
        } else {
          const currentPos = getClientPos(e);
          const deltaX = currentPos.x - previousPosition.x;
          const deltaY = currentPos.y - previousPosition.y;
          
          manifoldGroup.rotation.y += deltaX * 0.008;
          manifoldGroup.rotation.x += deltaY * 0.008;
          manifoldGroup.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, manifoldGroup.rotation.x));
          
          previousPosition = { ...currentPos };
        }
      };

      const handlePointerEnd = (e) => {
        e.preventDefault();
        isDragging = false;
        touchStartPos = null;
        pinchDistance = 0;
      };

      const canvas = renderer.domElement;
      
      canvas.addEventListener('pointerdown', handlePointerStart, { passive: false });
      canvas.addEventListener('pointermove', handlePointerMove, { passive: false });
      canvas.addEventListener('pointerup', handlePointerEnd, { passive: false });
      canvas.addEventListener('pointerleave', handlePointerEnd, { passive: false });
      canvas.addEventListener('pointercancel', handlePointerEnd, { passive: false });

      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomSpeed = 0.3;
        if (e.deltaY < 0) {
          currentZoom = Math.max(1, currentZoom - zoomSpeed);
        } else {
          currentZoom = Math.min(12, currentZoom + zoomSpeed);
        }
        camera.position.z = currentZoom;
      }, { passive: false });

      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      canvas.style.touchAction = 'none';

      animate();
    }

    function createCalabiYauGeometry(detail) {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const indices = [];

        for (let u = 0; u <= detail; u++) {
            for (let v = 0; v <= detail; v++) {
                const theta = (u / detail) * Math.PI * 2;
                const phi = (v / detail) * Math.PI * 2;
                
                const r1 = 1 + 0.3 * Math.sin(3 * theta) * Math.cos(2 * phi);
                const r2 = 1 + 0.2 * Math.cos(5 * theta) * Math.sin(3 * phi);
                const r3 = 1 + 0.15 * Math.sin(4 * theta + phi) * Math.cos(2 * theta - phi);
                
                const x = r1 * Math.sin(theta) * Math.cos(phi) + 0.2 * Math.sin(7 * theta) * Math.cos(4 * phi);
                const y = r2 * Math.sin(theta) * Math.sin(phi) + 0.2 * Math.cos(5 * theta) * Math.sin(6 * phi);
                const z = r3 * Math.cos(theta) + 0.15 * Math.sin(3 * theta) * Math.cos(3 * phi);

                vertices.push(x, y, z);
            }
        }
        for (let u = 0; u < detail; u++) {
            for (let v = 0; v < detail; v++) {
                const a = u * (detail + 1) + v;
                const b = a + detail + 1;
                const c = a + 1;
                const d = b + 1;

                indices.push(a, b, c);
                indices.push(b, d, c);
            }
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();
        return geometry;
    }

    function createManifold() {
      if (manifoldGroup) {
        scene.remove(manifoldGroup);
      }

      const geometry = createCalabiYauGeometry(complexity);

      const wireframeMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        wireframe: true,
        transparent: true,
        opacity: 0.7
      });

      const surfaceMaterial = new THREE.MeshPhongMaterial({
        color: 0x4a0080,
        emissive: 0x220066,
        specular: 0x00ffff,
        shininess: 50,
        transparent: true,
        opacity: 0.5,
        side: THREE.DoubleSide
      });
      
      manifoldGroup = new THREE.Group();
      const surface = new THREE.Mesh(geometry, surfaceMaterial);
      const wireframe = new THREE.Mesh(geometry, wireframeMaterial);
      manifoldGroup.add(surface);
      manifoldGroup.add(wireframe);
      scene.add(manifoldGroup);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (isRotating && !isDragging && manifoldGroup) {
        manifoldGroup.rotation.x += 0.003;
        manifoldGroup.rotation.y += 0.004;
        manifoldGroup.rotation.z += 0.0015;
      }
      renderer.render(scene, camera);
    }

    function zoomIn() {
      currentZoom = Math.max(1, currentZoom - 0.5);
      camera.position.z = currentZoom;
    }

    function zoomOut() {
      currentZoom = Math.min(12, currentZoom + 0.5);
      camera.position.z = currentZoom;
    }

    function resetZoom() {
      currentZoom = initialCameraZ;
      camera.position.z = currentZoom;
    }

    document.addEventListener('DOMContentLoaded', () => {
      const rotateBtn = document.getElementById('rotateBtn');
      if (rotateBtn) {
        rotateBtn.addEventListener('click', function() {
          isRotating = !isRotating;
          const h3 = this.querySelector('h3');
          if (h3) {
            h3.textContent = isRotating ? '⏸ Pause Rotation' : '▶ Resume Rotation';
          }
        });
      }

      document.getElementById('regenerateBtn')?.addEventListener('click', createManifold);
      document.getElementById('zoomInBtn')?.addEventListener('click', zoomIn);
      document.getElementById('zoomOutBtn')?.addEventListener('click', zoomOut);
      document.getElementById('resetZoomBtn')?.addEventListener('click', resetZoom);

      const complexitySlider = document.getElementById('complexitySlider');
      const complexityValue = document.getElementById('complexityValue');
      if (complexitySlider && complexityValue) {
        complexitySlider.addEventListener('input', function() {
          complexity = parseInt(this.value);
          complexityValue.textContent = complexity;
          createManifold();
        });
      }

      init();
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
      }
    });
  </script>
</body>
</html>